using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Numerics;

class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]);
        int height = int.Parse(inputs[1]);

        Map map = new Map(width, height);
        List<Protein> proteins = new List<Protein>();
        List<Organ> organs = new List<Organ>();
        List<Wall> walls = new List<Wall>();
        List<Organism> organisms = new List<Organism>();

        ProteinReserve playerProteins = new ProteinReserve();
        ProteinReserve opponentProteins = new ProteinReserve();

        while (true)
        {
            // New Round
            map.SetDirty();

            int entityCount = int.Parse(Console.ReadLine());
            for (int i = 0; i < entityCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int x = int.Parse(inputs[0]);
                int y = int.Parse(inputs[1]);
                string type = inputs[2];
                int owner = int.Parse(inputs[3]);
                int organId = int.Parse(inputs[4]);
                string organDir = inputs[5];
                int organParentId = int.Parse(inputs[6]);
                int organRootId = int.Parse(inputs[7]);

                if (Enum.TryParse(type, true, out ProteinType pt))
                {
                    proteins.Add(new Protein
                    {
                        id = $"protein_{x}_{y}",
                        type = pt,
                        position = new Vector2(x, y),
                    });
                }

                if (Enum.TryParse(type, true, out OrganType ot))
                {
                    if (ot == OrganType.Wall)
                    {
                        walls.Add(new Wall
                        {
                            id = $"wall_{x}_{y}",
                            position = new Vector2(x, y),
                        });

                        continue;
                    }

                    var parentOrganism = organisms.FirstOrDefault(x => x.id == organRootId);
                    if (parentOrganism == null)
                    {
                        parentOrganism = new Organism
                        {
                            id = organRootId,
                            proteins = owner == 1 
                                ? playerProteins 
                                : opponentProteins,
                            map = map,
                            navigation = new Navigation(map),
                        };

                        organisms.Add(parentOrganism);
                    }

                    var organ = new Organ
                    {
                        id = $"organ_{organId}",
                        organId = organId,
                        type = ot,
                        position = new Vector2(x, y),
                        isPlayerOwned = owner == 1,
                    };

                    organs.Add(organ);
                    parentOrganism.AddOrgan(organ);
                }
            }

            inputs = Console.ReadLine().Split(' ');
            playerProteins.a = int.Parse(inputs[0]);
            playerProteins.b = int.Parse(inputs[1]);
            playerProteins.c = int.Parse(inputs[2]);
            playerProteins.d = int.Parse(inputs[3]);

            inputs = Console.ReadLine().Split(' ');
            opponentProteins.a = int.Parse(inputs[0]);
            opponentProteins.b = int.Parse(inputs[1]);
            opponentProteins.c = int.Parse(inputs[2]);
            opponentProteins.d = int.Parse(inputs[3]);

            var entities = new List<IEntity>();
            entities.AddRange(proteins.Cast<IEntity>());
            entities.AddRange(walls.Cast<IEntity>());
            entities.AddRange(organs.Cast<IEntity>());
            map.SetEntities(entities);

            var playerOrganisms = organisms.Where(x => x.isPlayerOwned).ToArray();
            int requiredActionsCount = int.Parse(Console.ReadLine());
            for (int i = 0; i < requiredActionsCount; i++)
            {
                Organism organism = playerOrganisms[i];
                organism.CollectClosestProtein();
            }
        }
    }
}

public class Map
{
    private Cell[,] cells;
    private int rows;
    private int cols;

    public Cell[,] Cells => cells;

    public event Action<List<IEntity>> OnEntitiesAdded;
    public event Action<List<IEntity>> OnEntitiesRemoved;

    private static Dictionary<string, Vector2> movementDirections = new Dictionary<string, Vector2>
    {
        { "N", new Vector2(0, -1) },  // Up
        { "S", new Vector2(0, 1) }, // Down
        { "W", new Vector2(-1, 0) }, // Left
        { "E", new Vector2(1, 0) },  // Right
    };

    public Map(int width, int height)
    {
        cells = new Cell[width, height];
        rows = cells.GetLength(0);
        cols = cells.GetLength(1);        
        for (int x = 0; x < width; x++)
        {            
            for (int y = 0; y < height; y++)
            {
                cells[x,y] = new Cell
                {
                    position = new Vector2(x, y),
                    entity = null,
                    isDirty = true,
                };
            }
        }
    }

    public IEnumerable<Cell> GetNeighbours(Cell cell)
    {
        var directions = new (int dx, int dy)[] 
        { 
            (0, 1),
            (1, 0),
            (0, -1),
            (-1, 0),
        };

        foreach (var (dx, dy) in directions)
        {
            int newX = (int)cell.position.X + dx;
            int newY = (int)cell.position.Y + dy;

            if (newX >= 0 && newX < rows && newY >= 0 && newY < cols)
            {
                yield return cells[newX, newY];
            }
        }
    }

    public void SetDirty()
    {
        foreach (var cell in cells)
        {
            cell.isDirty = true;
        }
    }

    public void SetEntities(IEnumerable<IEntity> entities)
    {
        var addedEntities = new List<IEntity>();
        var removedEntities = new List<IEntity>();

        foreach (var entity in entities)
        {
            Cell cell = GetCellAtEntityPosition(entity);
            if (cell.entity?.id == entity.id)
            {
                // still the same entity as last turn
                cell.isDirty = false;    

                // Console.Error.WriteLine($"No Change: ({cell.position.X},{cell.position.Y}): {cell.entity}");            
            }
            else 
            {
                // entity was added to cell
                cell.entity = entity;
                cell.isDirty = false;
                addedEntities.Add(entity);
                // Console.Error.WriteLine($"Added: ({cell.position.X},{cell.position.Y}): {cell.entity}");
            }
        }

        foreach (var cell in cells)
        {
            if (cell.isDirty)
            {
                if (cell.entity != null)
                {
                    // entity was removed from cell
                    removedEntities.Add(cell.entity);
                    cell.entity = null;
                    cell.isDirty = false;

                    // Console.Error.WriteLine($"Removed: ({cell.position.X},{cell.position.Y}): {cell.entity}");
                }
                else 
                {
                    // empty cell
                    cell.isDirty = false;

                    // Console.Error.WriteLine($"Empty: ({cell.position.X},{cell.position.Y}): {cell.entity}");
                }
            }

            // Console.Error.WriteLine($"({cell.position.X},{cell.position.Y}): {cell.entity}");
        }

        if (addedEntities.Count > 0)
        {
            OnEntitiesAdded?.Invoke(addedEntities);
        }

        if (removedEntities.Count > 0)
        {
            OnEntitiesRemoved?.Invoke(removedEntities);
        }
    }

    public Cell GetCellAtEntityPosition(IEntity entity)    
    {
        return cells[(int)entity.position.X, (int)entity.position.Y];
    }

    public static int Distance(Vector2 a, Vector2 b)
    {
        return Math.Abs((int)b.X - (int)a.X) + Math.Abs((int)b.Y - (int)a.Y);
    }

    public static string GetDirectionKey(Vector2 dir)
    {
        return movementDirections.FirstOrDefault(x => x.Value == dir).Key;
    }    
}

public class Cell
{
    public Vector2 position;
    public IEntity entity;
    public bool isDirty;

    public override string ToString()
    {
        return $"({position.X},{position.Y}): {entity}";
    }
}

public class Organism
{
    private HashSet<int> organIds = new HashSet<int>();

    public int id;
    public Organ root;
    public List<Organ> organs = new List<Organ>();    
    public ProteinReserve proteins;
    public Map map;
    public Navigation navigation;
    public int actions = 1;

    public bool isPlayerOwned => root.isPlayerOwned;

    public void AddOrgan(Organ organ)
    {
        if (organIds.Contains(organ.organId))
        {
            return;
        }

        this.organs.Add(organ);
        this.organIds.Add(organ.organId);
        if (organ.type == OrganType.Root)
        {
            root = organ;
        }
    }

    public void CollectClosestProtein()
    {
        if (navigation.TryFindNearestProtein(this, out Navigation.NavigationData navData))
        {
            Cell origin = navData.origin;
            Cell target = navData.target;
            Organ organ = navData.organ;

            Console.Error.WriteLine($"Closest Protein: {target.entity} | Distance: {navData.distance}");
            if (navData.distance == 2)
            {
                Vector2 dir = Vector2.Normalize(target.position - origin.position);
                string dirKey = Map.GetDirectionKey(dir);
                Console.Error.WriteLine($"{dir} | {dirKey}");

                if (TryGrowHarvester(organ, target.position, dirKey))
                {
                    return;
                }
            }
            
            if (navData.distance > 2)
            {
                if (TryGrowAny(organ, target.position))
                {
                    return;
                }
            }           
        }
        
        Console.WriteLine("WAIT");
    }

    public bool TryGrowBasic(Organ organ, Vector2 destination)
    {
        return Grow(organ, OrganType.Basic, destination, "N");
    }

    public bool TryGrowHarvester(Organ organ, Vector2 destination, string direction)
    {
        return Grow(organ, OrganType.Harvester, destination, direction);
    }

    public bool TryGrowTentacle(Organ organ, Vector2 destination, string direction)
    {
        return Grow(organ, OrganType.Tentacle, destination, direction);
    }

    public bool TryGrowSporer(Organ organ, Vector2 destination, string direction)
    {
        return Grow(organ, OrganType.Sporer, destination, direction);        
    }

    public bool TryGrowAny(Organ organ, Vector2 destination)
    {
        if (TryGrowBasic(organ, destination) 
            || TryGrowHarvester(organ, destination, "N")
            || TryGrowTentacle(organ, destination, "N")
            || TryGrowSporer(organ, destination, "N"))
        {
            return true;
        }

        return false;
    }

    public bool CanGrow(OrganType organType)
    {
        switch(organType)
        {
            case OrganType.Basic:
                return proteins.a >= 1;
            case OrganType.Harvester:
                return proteins.c >= 1 && proteins.d >= 1;
            case OrganType.Tentacle:
                return proteins.b >= 1 && proteins.c >= 1;
            case OrganType.Sporer:
                return proteins.b >= 1 && proteins.d >= 1;
        }

        return false;
    }

    public bool CanSpore(Organ organ)
    {
        return organ.type == OrganType.Sporer
            && proteins.a > 0
            && proteins.b > 0
            && proteins.c > 0
            && proteins.d > 0;
    }

    private bool Grow(Organ organ, OrganType growthType, Vector2 destination, string direction)
    {
        if (!CanGrow(growthType))
        {        
            return false;
        }
        
        PayGrowthCosts(growthType);
        Console.Error.WriteLine($"Organ {organ.organId} (organism {id}) is growing a {growthType} from {organ.position} to {destination} facing {direction}");
        Console.WriteLine($"GROW {organ.organId} {destination.X} {destination.Y} {growthType.ToString().ToUpper()} {direction}");
        return true;
    }

    public bool Spore(Organ organ, Vector2 destination)
    {
        if (!CanSpore(organ))
        {
            return false;
        }

        PaySporeCosts();
        Console.Error.WriteLine($"Organ {organ.id} (organism {id}) is sporing a root from {organ.position} to {destination}");
        Console.WriteLine($"SPORE {organ.id} {destination.X} {destination.Y}");        
        return true;
    }

    private void PayGrowthCosts(OrganType organType)
    {
        switch(organType)
        {
            case OrganType.Basic:
                proteins.a--;
                break;
            case OrganType.Harvester:
                proteins.c--;
                proteins.d--;
                 break;
            case OrganType.Tentacle:
                proteins.b--;
                proteins.c--;
                break;
            case OrganType.Sporer:
                proteins.b--;
                proteins.d--;
                break;
        }

        actions--;
    }

    private void PaySporeCosts()
    {
        proteins.a--;
        proteins.b--;
        proteins.c--;
        proteins.d--;
        actions--;
    }
}

public class Navigation : IDisposable
{
    public struct NavigationData
    {
        public Organ organ;
        public Cell origin;
        public Cell target;
        public int distance;
        public List<Vector2> path;      
        public HashSet<Vector2> pathSet; 
    }

    private Map map;
    private IPathfinder pathfinder;

    // first string is organId
    // first integer is distance between organ and entity
    // second string is entityId
    private Dictionary<string, SortedDictionary<int, Dictionary<string, NavigationData>>> organNavDict;    

    public Navigation(Map map)
    {
        this.map = map;
        this.pathfinder = new AStar(map);
        organNavDict = new Dictionary<string, SortedDictionary<int, Dictionary<string, NavigationData>>>();

        map.OnEntitiesAdded += OnEntitiesAdded;
        map.OnEntitiesRemoved += OnEntitiesRemoved;
    }

    public void Dispose()
    {
        map.OnEntitiesAdded -= OnEntitiesAdded;
        map.OnEntitiesRemoved -= OnEntitiesRemoved;
    }

    private bool TryGetPath(Cell start, Cell end, out List<Vector2> path)
    {
        path = pathfinder
            .GetPath(start, end)?
            .Select(x => x.position)
            .ToList();

        return path != null;
    }

    private SortedDictionary<int, Dictionary<string, NavigationData>> FindPathsToProteins(Organ organ)
    {
        Cell organCell = map.GetCellAtEntityPosition(organ);
        var protein = FindNearestProteinBFS(organCell);
        if (protein == null)
        {   
            Console.Error.WriteLine($"Cant find path to proteins from organ {organ.organId}");
            return new SortedDictionary<int, Dictionary<string, NavigationData>>();
        }

        var proteinCell = protein.Value.cell;
        var path = protein.Value.path;

        int distance = Map.Distance(organCell.position, proteinCell.position);
        organNavDict.TryAdd(organ.id, new SortedDictionary<int, Dictionary<string, NavigationData>>());
        organNavDict[organ.id].TryAdd(distance, new Dictionary<string, NavigationData>());    
        organNavDict[organ.id][distance].Add(proteinCell.entity.id, new NavigationData
        {
            organ = organ,
            origin = organCell,
            target = proteinCell,
            distance = distance,
            path = path,
            pathSet = path.ToHashSet(),
        });

        return organNavDict[organ.id];
    }

    public bool TryFindNearestProtein(Organism organism, out NavigationData data)
    {
        data = default;       
        Cell closest = null;        
        int closestDistance = 999;

        foreach (Organ organ in organism.organs)
        {
            if (!organNavDict.TryGetValue(organ.id, out var distanceNavDict))
            {
                distanceNavDict = FindPathsToProteins(organ);
            }

            if (distanceNavDict.Count < 1)
            {
                continue;
            }

            var entityNavDict = distanceNavDict.First().Value;
            if (entityNavDict.Count < 1)
            {
                continue;
            }

            var navData = entityNavDict.First().Value;
            if (navData.distance < closestDistance)
            {                
                data = navData;       
                closest = navData.target;
                closestDistance = navData.distance;
            }
        }

        return closest != null;
    }

    public (Cell cell, List<Vector2> path)? FindNearestProteinBFS(Cell start, HashSet<Cell> exceptions = null)
    {
        var cells = map.Cells;
        int rows = cells.GetLength(0);
        int cols = cells.GetLength(1);

        var queue = new Queue<Cell>();
        var visited = new HashSet<Cell>();
        exceptions ??= new HashSet<Cell>();

        queue.Enqueue(start);
        visited.Add(start);

        while (queue.Count > 0)
        {
            Cell current = queue.Dequeue();

            // Check if it's a protein and not already targeted
            if (current.entity is Protein && !exceptions.Contains(current) && TryGetPath(start, current, out var path))
            {
                return (current, path);
            }

            // Explore neighbors
            foreach (Cell neighbor in map.GetNeighbours(current))
            {
                if (!visited.Contains(neighbor) && (neighbor.entity == null || !neighbor.entity.isObstacle))
                {
                    visited.Add(neighbor);
                    queue.Enqueue(neighbor);
                }
            }
        }

        // No protein found
        return null;
    }

    private void OnEntitiesAdded(IEnumerable<IEntity> entities)
    {
        foreach (var entity in entities)
        {
            if (entity == null) { continue; }
            for (int i = 0; i < organNavDict.Count; i++)
            {
                var distanceDict = organNavDict.ElementAt(i).Value;
                for (int j = 0; j < distanceDict.Count; j++)
                {
                    var distanceKvp = distanceDict.ElementAt(j);
                    var entityNavDict = distanceKvp.Value;
                    for (int k = 0; k < entityNavDict.Count; k++)
                    {
                        var kvp = entityNavDict.ElementAt(k);
                        var navData = kvp.Value;
                        if (navData.pathSet.Contains(entity.position))
                        {
                            if (TryGetPath(navData.origin, navData.target, out var path))
                            {
                                navData.path = path;
                                navData.pathSet = navData.path.ToHashSet();
                                entityNavDict[kvp.Key] = navData;
                            }
                            else 
                            {
                                entityNavDict.Remove(kvp.Key);
                            }                            
                        }

                        if (entityNavDict.Count < 1)
                        {
                            distanceDict.Remove(distanceKvp.Key);
                        }
                    }
                }
            }
        }
    }

    private void OnEntitiesRemoved(IEnumerable<IEntity> entities)
    {
        foreach (var entity in entities)
        {
            if (entity == null) { continue; }

            organNavDict.Remove(entity.id);
            for (int i = 0; i < organNavDict.Count; i++)
            {
                var distanceDict = organNavDict.ElementAt(i).Value;
                for (int j = 0; j < distanceDict.Count; j++)
                {
                    var distanceKvp = distanceDict.ElementAt(j);
                    var entityNavDict = distanceKvp.Value;
                    entityNavDict.Remove(entity.id);

                    for (int k = 0; k < entityNavDict.Count; k++)
                    {
                        var kvp = entityNavDict.ElementAt(k);
                        var navData = kvp.Value;
                        if (navData.pathSet.Contains(entity.position))
                        {
                            if (TryGetPath(navData.origin, navData.target, out var path))
                            {
                                navData.path = path;
                                navData.pathSet = navData.path.ToHashSet();
                                entityNavDict[kvp.Key] = navData;
                            }
                            else 
                            {
                                entityNavDict.Remove(kvp.Key);
                            }  
                        }
                    }
                    
                    if (entityNavDict.Count < 1)
                    {
                        distanceDict.Remove(distanceKvp.Key);
                    }
                }
            }
        }
    }    
}

public interface IPathfinder
{
    List<Cell> GetPath(Cell start, Cell end);
}

public class AStar : IPathfinder
{
    private class Node
    {
        public Cell Cell { get; set; }
        public int FCost { get; set; }
        public int GCost { get; set; }
        public int HCost { get; set; }
        public Node Parent { get; set; }
    }

    private Map map = default;
    private PriorityQueue<Node, int> openList;
    private HashSet<Cell> closedList;    

    public AStar(Map map)
    {
        this.map = map;
        openList = new PriorityQueue<Node, int>();
        closedList = new HashSet<Cell>();        
    }

    public List<Cell> GetPath(Cell start, Cell end)
    {
        openList.Clear();
        closedList.Clear();

        // Initialize the starting node
        var startNode = new Node
        {
            Cell = start,
            GCost = 0,  // No cost to start
            HCost = GetHCost(start, end), // Heuristic cost to the end
            FCost = 0 + GetHCost(start, end),
            Parent = null,
        };

        openList.Enqueue(startNode, startNode.FCost);

        while (openList.Count > 0)
        {
            // Get the node with the lowest fCost (highest priority)
            var currentNode = openList.Dequeue();

            // If we've reached the target, reconstruct the path
            if (currentNode.Cell == end)
            {
                return ReconstructPath(currentNode);
            }

            closedList.Add(currentNode.Cell);

            foreach (var neighbor in GetNeighbours(currentNode.Cell))
            {
                if (closedList.Contains(neighbor))
                {
                    continue;
                }                    

                int tentativeGCost = currentNode.GCost + GetMovementCost(currentNode.Cell, neighbor);

                // If the neighbor is not in the open list, or we found a shorter path to it
                var neighborNode = new Node
                {
                    Cell = neighbor,
                    GCost = tentativeGCost,
                    HCost = GetHCost(neighbor, end),
                    FCost = tentativeGCost + GetHCost(neighbor, end),
                    Parent = currentNode,
                };

                openList.Enqueue(neighborNode, neighborNode.FCost);
            }
        }

        return null;
    }

    private List<Cell> ReconstructPath(Node node)
    {
        var path = new List<Cell>();
        while (node != null)
        {
            path.Add(node.Cell);
            node = node.Parent;
        }
        path.Reverse();
        return path;
    }

    // Heuristic cost (e.g., Manhattan distance)
    private int GetHCost(Cell cell, Cell end)
    {        
        return Map.Distance(cell.position, end.position);
    }

    private int GetMovementCost(Cell from, Cell to)
    {
        return 1;
    }

    private IEnumerable<Cell> GetNeighbours(Cell cell)
    {
        return map.GetNeighbours(cell);
    }
}

public struct Organ : IEntity
{
    public string id { get; set; }
    public int organId { get; set; }
    public OrganType type { get; set; }
    public Vector2 position { get; set; }
    public bool isPlayerOwned { get; set; }
    public bool isObstacle => true;

    public override string ToString()
    {
        return $"Organ {type} ({(isPlayerOwned ? "Player" : "Opponent")})";
    }
}

public struct Protein : IEntity
{
    public string id { get; set; }
    public ProteinType type { get; set; }
    public Vector2 position { get; set; }
    public bool isObstacle => false;

    public override string ToString()
    {
        return $"Protein {type}";
    }
}

public struct Wall : IEntity
{
    public string id { get; set; }
    public Vector2 position { get; set; }
    public bool isObstacle => true;    

    public override string ToString()
    {
        return $"Wall";
    }
}

public interface IEntity
{
    string id { get; }
    Vector2 position { get; }
    bool isObstacle { get; }
}

public class ProteinReserve
{
    public int a;
    public int b;
    public int c;
    public int d;
}

public enum OrganType
{
    Wall,
    Root,
    Basic,
    Tentacle,
    Harvester,
    Sporer
}

public enum ProteinType
{
    A,
    B,
    C,
    D
}
