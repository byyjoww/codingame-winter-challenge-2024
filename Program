using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Numerics;

class Player
{
    private static DateTime ts = default;
    private static bool logEnabled = true;

    static void Main(string[] args)
    {
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]);
        int height = int.Parse(inputs[1]);

        Map map = new Map(width, height);
        List<Organism> organisms = new List<Organism>();

        ProteinReserve playerProteins = new ProteinReserve();
        ProteinReserve opponentProteins = new ProteinReserve();

        while (true)
        {
            // New round starts when we first read input     
            int entityCount = int.Parse(Console.ReadLine());

            ts = DateTime.UtcNow;
            Player.Log($"Start turn");

            List<Protein> proteins = new List<Protein>();
            List<Organ> organs = new List<Organ>();
            List<Wall> walls = new List<Wall>();

            for (int i = 0; i < entityCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int x = int.Parse(inputs[0]);
                int y = int.Parse(inputs[1]);
                string type = inputs[2];
                int owner = int.Parse(inputs[3]);
                int organId = int.Parse(inputs[4]);
                string organDir = inputs[5];
                int organParentId = int.Parse(inputs[6]);
                int organRootId = int.Parse(inputs[7]);

                if (Enum.TryParse(type, true, out ProteinType pt))
                {
                    proteins.Add(new Protein
                    {
                        id = $"protein_{x}_{y}",
                        type = pt,
                        position = new Vector2(x, y),
                        isHarvested = false,
                    });
                }

                if (Enum.TryParse(type, true, out OrganType ot))
                {
                    if (ot == OrganType.Wall)
                    {
                        walls.Add(new Wall
                        {
                            id = $"wall_{x}_{y}",
                            position = new Vector2(x, y),
                        });

                        continue;
                    }

                    bool isPlayerOwned = owner == 1;
                    var parentOrganism = organisms.FirstOrDefault(x => x.id == organRootId);
                    if (parentOrganism == null)
                    {                        
                        parentOrganism = new Organism
                        {
                            id = organRootId,
                            proteins = isPlayerOwned
                                ? playerProteins
                                : opponentProteins,
                            map = isPlayerOwned 
                                ? map
                                : null,
                            navigation = isPlayerOwned
                                ? new Navigation(map)
                                : null,
                        };

                        organisms.Add(parentOrganism);
                    }

                    var organ = new Organ
                    {
                        id = $"organ_{organId}",
                        organId = organId,
                        type = ot,
                        position = new Vector2(x, y),
                        direction = organDir,
                        isPlayerOwned = isPlayerOwned,
                    };

                    organs.Add(organ);
                    parentOrganism.AddOrgan(organ);
                }
            }

            inputs = Console.ReadLine().Split(' ');
            playerProteins.a = int.Parse(inputs[0]);
            playerProteins.b = int.Parse(inputs[1]);
            playerProteins.c = int.Parse(inputs[2]);
            playerProteins.d = int.Parse(inputs[3]);

            inputs = Console.ReadLine().Split(' ');
            opponentProteins.a = int.Parse(inputs[0]);
            opponentProteins.b = int.Parse(inputs[1]);
            opponentProteins.c = int.Parse(inputs[2]);
            opponentProteins.d = int.Parse(inputs[3]);

            var entities = new List<IEntity>();
            entities.AddRange(proteins.Cast<IEntity>());
            entities.AddRange(walls.Cast<IEntity>());
            entities.AddRange(organs.Cast<IEntity>());

            map.SetEntities(entities);

            var playerOrganisms = organisms.Where(x => x.isPlayerOwned).ToArray();
            int requiredActionsCount = int.Parse(Console.ReadLine());
            for (int i = 0; i < requiredActionsCount; i++)
            {
                Organism organism = playerOrganisms[i];
                organism.Prepare();
                organism.CollectClosestProtein();
            }

            Player.Log($"End turn");
        }
    }

    public static void Log(string message)
    {
        if (!logEnabled) { return; }
        Console.Error.WriteLine($"[{GetTimeSinceStartOfTurn()}] {message}");
    }

    public static void Command(string message)
    {
        Console.WriteLine(message);
    }

    public static float GetTimeSinceStartOfTurn()
    {
        return (float)(DateTime.UtcNow - ts).TotalMilliseconds;
    }
}

public class Map
{
    private Cell[,] cells;
    private int width;
    private int height;
    private HashSet<Cell> harvested; 

    public Cell[,] Cells => cells;
    public HashSet<Cell> Harvested => harvested;

    public List<IEntity> OnEntitiesAdded;
    public List<IEntity> OnEntitiesRemoved;
    public HashSet<string> OnProteinsHarvested;

    private static Dictionary<string, Vector2> movementDirections = new Dictionary<string, Vector2>
    {
        { "N", new Vector2(0, -1) },  // Up
        { "S", new Vector2(0, 1) }, // Down
        { "W", new Vector2(-1, 0) }, // Left
        { "E", new Vector2(1, 0) },  // Right
    };

    public Map(int width, int height)
    {
        cells = new Cell[width, height];
        harvested = new HashSet<Cell>();
        this.width = cells.GetLength(0);
        this.height = cells.GetLength(1);
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                cells[x, y] = new Cell
                {
                    position = new Vector2(x, y),
                    entity = null,
                    isDirty = true,
                };
            }
        }
    }

    public IEnumerable<Cell> GetNeighbours(Cell cell)
    {
        foreach (var dir in movementDirections.Values)
        {
            int newX = (int)cell.position.X + (int)dir.X;
            int newY = (int)cell.position.Y + (int)dir.Y;

            if (newX >= 0 && newX < width && newY >= 0 && newY < height)
            {
                yield return cells[newX, newY];
            }
        }
    }

    public void SetEntities(IEnumerable<IEntity> entities)
    {
        var addedEntities = new List<IEntity>();
        var removedEntities = new List<IEntity>();
        var harvestedIds = new HashSet<string>();

        foreach (var cell in cells)
        {
            cell.isDirty = true;
        }

        foreach (var entity in entities)
        {
            Cell cell = GetCellAtEntityPosition(entity);
            if (cell.entity?.id == entity.id)
            {
                // still the same entity as last turn
                cell.isDirty = false;

                // Player.Log($"No Change: ({cell.position.X},{cell.position.Y}): {cell.entity}");            
            }
            else
            {
                // entity was added to cell
                cell.entity = entity;
                cell.isDirty = false;
                addedEntities.Add(entity);
                // Player.Log($"Added: ({cell.position.X},{cell.position.Y}): {cell.entity}");
            }
        }

        foreach (var cell in cells)
        {
            if (cell.isDirty)
            {
                if (cell.entity != null)
                {
                    // entity was removed from cell
                    var prev = cell.entity;
                    removedEntities.Add(prev);
                    cell.entity = null;
                    cell.isDirty = false;

                    // Player.Log($"Removed: ({cell.position.X},{cell.position.Y}): {prev}");
                }
                else
                {
                    // empty cell
                    cell.isDirty = false;

                    // Player.Log($"Empty: ({cell.position.X},{cell.position.Y}): {cell.entity}");
                }
            }
        }
       
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                var cell = cells[x, y];
                if (cell.entity is Organ oEntity && oEntity.type == OrganType.Harvester)
                {
                    var facing = GetCellForPositionAtDirection(cell, oEntity.direction);
                    if (facing != null && facing.entity is Protein pEntity)
                    {
                        pEntity.isHarvested = true;
                        facing.entity = pEntity;
                        harvestedIds.Add(facing.entity.id);
                        harvested.Add(facing);
                    }
                }
            }
        }

        harvested.RemoveWhere(x => !(x.entity is Protein));
        OnEntitiesAdded = addedEntities;
        OnEntitiesRemoved = removedEntities;
        OnProteinsHarvested = harvestedIds;
    }

    public Cell GetCellAtEntityPosition(IEntity entity)
    {
        return cells[(int)entity.position.X, (int)entity.position.Y];
    }

    public Cell GetCellForPositionAtDirection(Cell cell, string direction)
    {
        if (!movementDirections.ContainsKey(direction))
        {
            return null;
        }

        Vector2 offset = movementDirections[direction];
        Vector2 targetPos = cell.position + offset;

        int targetX = (int)targetPos.X;
        int targetY = (int)targetPos.Y;

        if (targetX >= 0 && targetX < width && targetY >= 0 && targetY < height)
        {
            return cells[targetX, targetY];
        }

        return null;
    }

    public static int Distance(Vector2 a, Vector2 b)
    {
        return Math.Abs((int)b.X - (int)a.X) + Math.Abs((int)b.Y - (int)a.Y);
    }

    public static string GetDirectionKey(Vector2 dir)
    {
        return movementDirections.FirstOrDefault(x => x.Value == dir).Key;
    }
}

public class Cell
{
    public Vector2 position;
    public IEntity entity;
    public bool isDirty;

    public override string ToString()
    {
        return $"({position.X},{position.Y}): {entity}";
    }
}

public class Organism
{
    private HashSet<int> organIds = new HashSet<int>();

    public int id;
    public Organ root;
    public List<Organ> organs = new List<Organ>();
    public ProteinReserve proteins;
    public Map map;
    public Navigation navigation;
    public int actions = 1;

    public bool isPlayerOwned => root.isPlayerOwned;

    private HashSet<ProteinType> desired = new HashSet<ProteinType>()
    {
        ProteinType.A,
        ProteinType.B,
        ProteinType.C,
        ProteinType.D,
    };

    public void AddOrgan(Organ organ)
    {
        if (organIds.Contains(organ.organId))
        {
            return;
        }

        this.organs.Add(organ);
        this.organIds.Add(organ.organId);
        if (organ.type == OrganType.Root)
        {
            root = organ;
        }
    }

    public void Prepare()
    {
        navigation.Refresh();
    }

    public void CollectClosestProtein()
    {
        if (navigation.TryFindNearestProtein(this, 1, desired, out Navigation.NavigationData navData))
        {
            if (HarvestProtein((Organ)navData.origin.entity, (Protein)navData.target.entity, navData.distance, navData.path))
            {
                return;
            }
        }
        
        Player.Command("WAIT");
    }

    private bool HarvestProtein(Organ organ, Protein protein, int distance, List<Vector2> path)
    {
        Player.Log($"Closest protein to {organ} is {protein} | Distance: {distance} | Path: [{string.Join(", ", path)}]");
        if (distance == 2 && CanGrow(OrganType.Harvester))
        {
            Vector2 harvesterPos = path[0];
            Vector2 harvesterDir = Vector2.Normalize(protein.position - harvesterPos);
            string dirKey = Map.GetDirectionKey(harvesterDir);
            if (TryGrowHarvester(organ, harvesterPos, dirKey))
            {
                desired.Remove(protein.type);
                return true;
            }
        }
        else
        {
            if (TryGrowAny(organ, path[0]))
            {
                return true;
            }
        }

        if (distance > 2)
        {
            if (TryGrowAny(organ, path[0]))
            {
                return true;
            }
        }

        return false;
    }

    public bool TryGrowBasic(Organ organ, Vector2 destination)
    {
        return Grow(organ, OrganType.Basic, destination, "N");
    }

    public bool TryGrowHarvester(Organ organ, Vector2 destination, string direction)
    {
        return Grow(organ, OrganType.Harvester, destination, direction);
    }

    public bool TryGrowTentacle(Organ organ, Vector2 destination, string direction)
    {
        return Grow(organ, OrganType.Tentacle, destination, direction);
    }

    public bool TryGrowSporer(Organ organ, Vector2 destination, string direction)
    {
        return Grow(organ, OrganType.Sporer, destination, direction);
    }

    public bool TryGrowAny(Organ organ, Vector2 destination)
    {
        if (TryGrowBasic(organ, destination)
            || TryGrowTentacle(organ, destination, "N")
            || TryGrowSporer(organ, destination, "N")
            || TryGrowHarvester(organ, destination, "N"))
        {
            return true;
        }

        return false;
    }

    public bool CanGrow(OrganType organType)
    {
        switch (organType)
        {
            case OrganType.Basic:
                return proteins.a >= 1;
            case OrganType.Harvester:
                return proteins.c >= 1 && proteins.d >= 1;
            case OrganType.Tentacle:
                return proteins.b >= 1 && proteins.c >= 1;
            case OrganType.Sporer:
                return proteins.b >= 1 && proteins.d >= 1;
        }

        return false;
    }

    public bool CanSpore(Organ organ)
    {
        return organ.type == OrganType.Sporer
            && proteins.a > 0
            && proteins.b > 0
            && proteins.c > 0
            && proteins.d > 0;
    }

    private bool Grow(Organ organ, OrganType growthType, Vector2 destination, string direction)
    {
        if (!CanGrow(growthType))
        {
            return false;
        }

        PayGrowthCosts(growthType);
        Player.Log($"Organ {organ.organId} (organism {id}) is growing a {growthType} from {organ.position} to {destination} facing {direction}");
        Player.Command($"GROW {organ.organId} {destination.X} {destination.Y} {growthType.ToString().ToUpper()} {direction}");
        return true;
    }

    public bool Spore(Organ organ, Vector2 destination)
    {
        if (!CanSpore(organ))
        {
            return false;
        }

        PaySporeCosts();
        Player.Log($"Organ {organ.id} (organism {id}) is sporing a root from {organ.position} to {destination}");
        Player.Command($"SPORE {organ.id} {destination.X} {destination.Y}");
        return true;
    }

    private void PayGrowthCosts(OrganType organType)
    {
        switch (organType)
        {
            case OrganType.Basic:
                proteins.a--;
                break;
            case OrganType.Harvester:
                proteins.c--;
                proteins.d--;
                break;
            case OrganType.Tentacle:
                proteins.b--;
                proteins.c--;
                break;
            case OrganType.Sporer:
                proteins.b--;
                proteins.d--;
                break;
        }

        actions--;
    }

    private void PaySporeCosts()
    {
        proteins.a--;
        proteins.b--;
        proteins.c--;
        proteins.d--;
        actions--;
    }
}

public class Navigation
{
    public struct NavigationData
    {
        public Cell origin;
        public Cell target;
        public int distance;
        public int score;
        public List<Vector2> path;
        public HashSet<Vector2> pathSet;

        public override string ToString()
        {
            return $"{origin.position} => {target.position} | Distance: {distance} | Path: {string.Join(", ", path)}";
        }
    }

    private Map map;
    private IPathfinder pathfinder;

    // first string is organId
    // first integer is distance between organ and entity
    // second string is entityId
    private Dictionary<string, SortedDictionary<int, Dictionary<string, NavigationData>>> organNavDict;

    public Navigation(Map map)
    {
        this.map = map;
        this.pathfinder = new AStar(map);      
        organNavDict = new Dictionary<string, SortedDictionary<int, Dictionary<string, NavigationData>>>();
    }

    public void Refresh()
    {
        OnEntitiesAdded(map.OnEntitiesAdded);
        OnEntitiesRemoved(map.OnEntitiesRemoved);
        OnProteinsHarvested(map.OnProteinsHarvested);
    }

    public bool TryFindNearestProtein(Organism organism, int minDistance, HashSet<ProteinType> types, out NavigationData data)
    {
        data = default;
        Cell closest = null;
        int smallestScore = int.MaxValue;        

        foreach (Organ organ in organism.organs)
        {
            if (!organNavDict.TryGetValue(organ.id, out var scoreNavDict))
            {
                scoreNavDict = FindPathsToAllProteins(organ, maxDistance: 5, includeHarvested: true);
            }

            if (scoreNavDict.Count < 1)
            {
                continue;
            }

            var result = scoreNavDict.FirstOrDefault(x => CachedSearchResultSelector(x, minDistance, types));
            if (result.Equals(default(KeyValuePair<int, NavigationData>)) || result.Value == null || result.Value.Count < 1)
            {
                continue;
            }

            var navData = result.Value.FirstOrDefault(x => CachedSearchResultSelector(x, minDistance, types)).Value;
            if (navData.Equals(default(NavigationData)))
            {
                continue;
            }

            if (navData.score < smallestScore)
            {
                data = navData;
                closest = navData.target;
                smallestScore = navData.score;
            }
        }

        return closest != null;
    }

    private bool CachedSearchResultSelector(KeyValuePair<int, Dictionary<string, NavigationData>> kvp, int minDistance, HashSet<ProteinType> types)
    {
        bool isOverMinDistance = kvp.Value.Any(y => y.Value.distance > minDistance);
        bool isNotHarvested = kvp.Value.Any(y => y.Value.target.entity is Protein pEntity && !pEntity.isHarvested);
        bool requiresType = types != null && types.Count > 0;
        bool isOfRequiredType = kvp.Value.Any(y => y.Value.target.entity is Protein pEntity && types.Contains(pEntity.type));
        return isOverMinDistance
            & isNotHarvested
            && (!requiresType || isOfRequiredType);
    }

    private bool CachedSearchResultSelector(KeyValuePair<string, NavigationData> kvp, int minDistance, HashSet<ProteinType> types)
    {
        bool isProtein = kvp.Value.target.entity is Protein;
        bool isOverMinDistance = kvp.Value.distance > minDistance;
        bool isNotHarvested = isProtein && !((Protein)kvp.Value.target.entity).isHarvested;
        bool requiresType = types != null && types.Count > 0;
        bool isOfRequiredType = isProtein && types.Contains(((Protein)kvp.Value.target.entity).type);
        return isNotHarvested
            && (!requiresType || isOfRequiredType);
    }    

    private SortedDictionary<int, Dictionary<string, NavigationData>> FindPathsToAllProteins(Organ organ, int maxDistance, HashSet<ProteinType> types = null, bool includeHarvested = false)
    {
        Cell organCell = map.GetCellAtEntityPosition(organ);
        Cell[] proteins = map.Cells
            .Cast<Cell>()
            .Where(x => x.entity is Protein pEntity
                && (types == null || types.Contains(pEntity.type))
                && (includeHarvested || !pEntity.isHarvested)
                && Map.Distance(organ.position, x.position) <= maxDistance)
            .ToArray();

        foreach (var protein in proteins)
        {
            CalculatePathFromOrganToProtein(organCell, protein);
        }

        // in case we dont find any valid paths
        organNavDict.TryAdd(organ.id, new SortedDictionary<int, Dictionary<string, NavigationData>>());
        return organNavDict[organ.id];
    }

    private void CalculatePathFromOrganToProtein(Cell start, Cell end)
    {
        if (start.entity == null || !TryGetPath(start, end, out var path))
        {
            return;
        }
        
        var cells = path.cells.Select(x => x.position);
        organNavDict.TryAdd(start.entity.id, new SortedDictionary<int, Dictionary<string, NavigationData>>());
        organNavDict[start.entity.id].TryAdd(path.score, new Dictionary<string, NavigationData>());
        var navData = new NavigationData
        {
            origin = start,
            target = end,
            distance = path.cells.Count,
            score = path.score,
            path = cells.ToList(),
            pathSet = cells.ToHashSet(),
        };

        organNavDict[start.entity.id][path.score].TryAdd(end.entity.id, navData);
    }

    private bool TryGetPath(Cell start, Cell end, out PathResult path)
    {

        path = pathfinder.GetPath(start, end);
        return path != null;
    }

    private void OnEntitiesAdded(IEnumerable<IEntity> entities)
    {
        if (entities.Count() > 0)
        {
            var recalculations = new List<Action>();
            var entityPositions = entities
                .Select(x => x.position)
                .ToHashSet();

            for (int i = 0; i < organNavDict.Count; i++)
            {
                var distanceDict = organNavDict.ElementAt(i).Value;
                for (int j = 0; j < distanceDict.Count; j++)
                {
                    var distanceKvp = distanceDict.ElementAt(j);
                    var entityNavDict = distanceKvp.Value;
                    for (int k = 0; k < entityNavDict.Count; k++)
                    {
                        var kvp = entityNavDict.ElementAt(k);
                        var navData = kvp.Value;
                        if (navData.pathSet.Overlaps(entityPositions))
                        {
                            recalculations.Add(delegate
                            {
                                entityNavDict.Remove(kvp.Key);
                                CalculatePathFromOrganToProtein(navData.origin, navData.target);
                            });
                        }

                        if (entityNavDict.Count < 1)
                        {
                            distanceDict.Remove(distanceKvp.Key);
                        }
                    }
                }
            }

            foreach (var recalc in recalculations)
            {
                recalc?.Invoke();
            }
        }
    }

    private void OnEntitiesRemoved(IEnumerable<IEntity> entities)
    {
        if (entities.Count() > 0)
        {
            var recalculations = new List<Action>();
            var entityPositions = entities
                .Select(x => x.position)
                .ToHashSet();

            foreach (var entity in entities)
            {
                organNavDict.Remove(entity.id);
            }

            for (int i = 0; i < organNavDict.Count; i++)
            {
                var distanceDict = organNavDict.ElementAt(i).Value;
                for (int j = 0; j < distanceDict.Count; j++)
                {
                    var distanceKvp = distanceDict.ElementAt(j);
                    var entityNavDict = distanceKvp.Value;

                    foreach (var entity in entities)
                    {
                        entityNavDict.Remove(entity.id);
                    }

                    for (int k = 0; k < entityNavDict.Count; k++)
                    {
                        var kvp = entityNavDict.ElementAt(k);
                        var navData = kvp.Value;
                        if (navData.pathSet.Overlaps(entityPositions))
                        {
                            recalculations.Add(delegate
                            {
                                entityNavDict.Remove(kvp.Key);
                                CalculatePathFromOrganToProtein(navData.origin, navData.target);
                            });
                        }
                    }

                    if (entityNavDict.Count < 1)
                    {
                        distanceDict.Remove(distanceKvp.Key);
                    }
                }
            }

            foreach (var recalc in recalculations)
            {
                recalc?.Invoke();
            }
        }
    }

    private void OnProteinsHarvested(HashSet<string> proteinIds)
    {
        foreach (var pid in proteinIds)
        {
            for (int i = 0; i < organNavDict.Count; i++)
            {
                var distanceDict = organNavDict.ElementAt(i).Value;
                for (int j = 0; j < distanceDict.Count; j++)
                {
                    var distanceKvp = distanceDict.ElementAt(j);
                    var entityNavDict = distanceKvp.Value;
                    entityNavDict.Remove(pid);
                    if (entityNavDict.Count < 1)
                    {
                        distanceDict.Remove(distanceKvp.Key);
                    }
                }
            }
        }
    }
}

public interface IPathfinder
{
    PathResult GetPath(Cell start, Cell end, int maxDeviation);
}

public class PathResult
{
    public List<Cell> cells;
    public int score;
}

public class AStar : IPathfinder
{    
    private class Node
    {
        public Cell Cell { get; set; }
        public int FCost { get; set; }
        public int GCost { get; set; }
        public int HCost { get; set; }
        public Node Parent { get; set; }
    }

    private Map map = default;
    private PriorityQueue<Node, int> openList;
    private HashSet<Cell> closedList;

    public AStar(Map map)
    {
        this.map = map;
        openList = new PriorityQueue<Node, int>();
        closedList = new HashSet<Cell>();
    }

    public PathResult GetPath(Cell start, Cell end, int maxDeviation)
    {
        openList.Clear();
        closedList.Clear();

        // Initialize the starting node
        var startNode = new Node
        {
            Cell = start,
            GCost = 0,  // No cost to start
            HCost = GetHCost(start, end), // Heuristic cost to the end
            FCost = 0 + GetHCost(start, end),
            Parent = null,
        };

        openList.Enqueue(startNode, startNode.FCost);

        while (openList.Count > 0)
        {
            // Get the node with the lowest fCost (highest priority)
            var currentNode = openList.Dequeue();

            // If we've reached the target, reconstruct the path
            if (currentNode.Cell == end)
            {
                return ReconstructPath(currentNode);
            }

            closedList.Add(currentNode.Cell);

            foreach (var neighbor in GetNeighbours(currentNode.Cell))
            {
                bool isDestination = neighbor == end;
                bool isObstacle = (neighbor.entity != null && neighbor.entity.isObstacle);      
                bool isTooFar = GetHCost(neighbor, start) > maxDeviation;
                if (!isDestination && (isObstacle || isTooFar || closedList.Contains(neighbor)))
                {
                    continue;
                }

                int tentativeGCost = currentNode.GCost + GetMovementCost(currentNode.Cell, neighbor);

                // If the neighbor is not in the open list, or we found a shorter path to it
                var neighborNode = new Node
                {
                    Cell = neighbor,
                    GCost = tentativeGCost,
                    HCost = GetHCost(neighbor, end),
                    FCost = tentativeGCost + GetHCost(neighbor, end),
                    Parent = currentNode,
                };

                openList.Enqueue(neighborNode, neighborNode.FCost);
            }
        }

        return null;
    }

    private PathResult ReconstructPath(Node node)
    {
        var path = new List<Cell>();
        int gCost = 0;
        while (node != null)
        {
            if (node.Parent != null)
            {
                path.Add(node.Cell);
            }
            
            gCost += node.GCost - (node.Parent?.GCost ?? 0);
            node = node.Parent;
        }

        path.Reverse();
        return new PathResult
        {
            cells = path,
            score = gCost,
        };
    }

    // Heuristic cost (e.g., Manhattan distance)
    private int GetHCost(Cell cell, Cell end)
    {
        return Map.Distance(cell.position, end.position);
    }

    private int GetMovementCost(Cell from, Cell to)
    {
        if (to.entity != null && to.entity is Protein pEntity)
        {
            return pEntity.isHarvested 
                ? 15 
                : 10;
        }

        return 1;
    }

    private IEnumerable<Cell> GetNeighbours(Cell cell)
    {
        return map.GetNeighbours(cell);
    }
}

public struct Organ : IEntity
{
    public string id { get; set; }
    public int organId { get; set; }
    public OrganType type { get; set; }
    public Vector2 position { get; set; }
    public string direction { get; set; }
    public bool isPlayerOwned { get; set; }    
    public bool isObstacle => true;

    public override string ToString()
    {
        return $"Organ {type} ({(isPlayerOwned ? "Player" : "Opponent")})";
    }
}

public struct Protein : IEntity
{
    public string id { get; set; }
    public ProteinType type { get; set; }
    public Vector2 position { get; set; }
    public bool isHarvested { get; set; }    
    public bool isObstacle => false;

    public override string ToString()
    {
        return $"Protein {type} (harvested: {isHarvested})";
    }
}

public struct Wall : IEntity
{
    public string id { get; set; }
    public Vector2 position { get; set; }  
    public bool isObstacle => true;  

    public override string ToString()
    {
        return $"Wall";
    }
}

public interface IEntity
{
    string id { get; }
    Vector2 position { get; }    
    bool isObstacle { get; }
}

public class ProteinReserve
{
    public int a;
    public int b;
    public int c;
    public int d;
}

public enum OrganType
{
    Wall,
    Root,
    Basic,
    Tentacle,
    Harvester,
    Sporer
}

public enum ProteinType
{
    A,
    B,
    C,
    D
}
