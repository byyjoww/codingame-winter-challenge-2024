using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Numerics;

class Player
{
    private static DateTime ts = default;
    private static bool logEnabled = true;
    private static bool commentsEnabled = true;
    private static Dictionary<string, bool> comments = new Dictionary<string, bool>();

    static void Main(string[] args)
    {
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]);
        int height = int.Parse(inputs[1]);

        Map map = new Map(width, height);
        List<Organism> organisms = new List<Organism>();
        HashSet<Vector2> intents = new HashSet<Vector2>();

        ProteinReserve playerProteins = new ProteinReserve();
        ProteinReserve opponentProteins = new ProteinReserve();

        while (true)
        {
            // New round starts when we first read input     
            int entityCount = int.Parse(Console.ReadLine());

            ts = DateTime.UtcNow;
            comments.Clear();
            Player.Log($"Start turn");

            List<Protein> proteins = new List<Protein>();
            List<Organ> organs = new List<Organ>();
            List<Wall> walls = new List<Wall>();

            for (int i = 0; i < entityCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                int x = int.Parse(inputs[0]);
                int y = int.Parse(inputs[1]);
                string type = inputs[2];
                int owner = int.Parse(inputs[3]);
                int organId = int.Parse(inputs[4]);
                string organDir = inputs[5];
                int organParentId = int.Parse(inputs[6]);
                int organRootId = int.Parse(inputs[7]);

                if (Enum.TryParse(type, true, out ProteinType pt))
                {
                    proteins.Add(new Protein
                    {
                        id = $"protein_{x}_{y}",
                        type = pt,
                        position = new Vector2(x, y),
                        isHarvested = false,
                    });
                }

                if (Enum.TryParse(type, true, out OrganType ot))
                {
                    if (ot == OrganType.Wall)
                    {
                        walls.Add(new Wall
                        {
                            id = $"wall_{x}_{y}",
                            position = new Vector2(x, y),
                        });

                        continue;
                    }

                    bool isPlayerOwned = owner == 1;
                    var parentOrganism = organisms.FirstOrDefault(x => x.id == organRootId);
                    if (parentOrganism == null)
                    {                        
                        parentOrganism = new Organism
                        {
                            id = organRootId,
                            proteins = isPlayerOwned
                                ? playerProteins
                                : opponentProteins,
                            map = isPlayerOwned 
                                ? map
                                : null,
                            navigation = isPlayerOwned
                                ? new Navigation(map)
                                : null,
                        };

                        organisms.Add(parentOrganism);
                    }

                    var organ = new Organ
                    {
                        id = $"organ_{organId}",
                        organId = organId,
                        type = ot,
                        position = new Vector2(x, y),
                        direction = organDir,
                        isPlayerOwned = isPlayerOwned,
                    };

                    organs.Add(organ);
                    parentOrganism.AddOrgan(organ);
                }
            }

            inputs = Console.ReadLine().Split(' ');
            playerProteins.a = int.Parse(inputs[0]);
            playerProteins.b = int.Parse(inputs[1]);
            playerProteins.c = int.Parse(inputs[2]);
            playerProteins.d = int.Parse(inputs[3]);

            inputs = Console.ReadLine().Split(' ');
            opponentProteins.a = int.Parse(inputs[0]);
            opponentProteins.b = int.Parse(inputs[1]);
            opponentProteins.c = int.Parse(inputs[2]);
            opponentProteins.d = int.Parse(inputs[3]);

            var entities = new List<IEntity>();
            entities.AddRange(proteins.Cast<IEntity>());
            entities.AddRange(walls.Cast<IEntity>());
            entities.AddRange(organs.Cast<IEntity>());

            map.SetEntities(entities);

            foreach (var entity in map.OnEntitiesRemoved)
            {
                if (entity is Organ oEntity && oEntity.type == OrganType.Root)
                {
                    organisms.RemoveAll(x => x.id == oEntity.organId);
                }
            }

            var playerOrganisms = organisms.Where(x => x.IsPlayerOwned).ToList();
            int requiredActionsCount = int.Parse(Console.ReadLine());
            for (int i = 0; i < requiredActionsCount; i++)
            {
                Organism organism = playerOrganisms[i];
                organism.Prepare();
                organism.Act();
            }

            if (playerOrganisms.TrueForAll(x => x.hasNoMoreActions))
            {
                playerOrganisms.ForEach(y => y.expandIntoHarvestedProteins = true);
            }

            Player.Log($"End turn");
        }
    }

    public static void Log(string message)
    {
        if (!logEnabled) { return; }
        Console.Error.WriteLine($"[{GetTimeSinceStartOfTurn()}] {message}");
    }

    public static void Command(string message, string comment = "")
    {                
        Console.WriteLine(message + GetComment(comment));
    }

    public static void AddComment(string comment, bool clear = false, bool persistent = false)
    {
        if (!commentsEnabled) { return; }
        if (clear) { ClearComments(); }
        comments.TryAdd(comment, persistent);
    }    

    public static void ClearComments()
    {
        if (!commentsEnabled) { return; }
        var keysToRemove = comments
            .Where(kv => kv.Value == false)
            .Select(kv => kv.Key)
            .ToArray();

        foreach (var key in keysToRemove)
        {
            comments.Remove(key);
        }
    }

    public static float GetTimeSinceStartOfTurn()
    {
        return (float)(DateTime.UtcNow - ts).TotalMilliseconds;
    }

    private static string GetComment(string cmdComment)
    {
        if (!commentsEnabled) { return string.Empty; }
        
        string comment = cmdComment != "" 
            ? cmdComment
            : string.Join(", ", Player.comments.Keys);

        return comment.Length > 0
            ? " " + comment.ToUpper()
            : string.Empty;
    }
}

public class Map
{
    private Cell[,] cells;
    private int width; // between 16 and 24
    private int height; // between 8 and 12
    private HashSet<Cell> harvested;
    private HashSet<Cell> targeted;

    public Cell[,] Cells => cells;
    public HashSet<Cell> Harvested => harvested;
    public HashSet<Cell> Targeted => targeted;

    public List<IEntity> OnEntitiesAdded;
    public List<IEntity> OnEntitiesRemoved;
    public HashSet<string> OnProteinsHarvested;

    public static Dictionary<Vector2, string> directionVectorsToKeys;
    public static Dictionary<string, Vector2> directionKeysToVectors = new Dictionary<string, Vector2>
    {
        { "N", new Vector2(0, -1) }, // Up
        { "S", new Vector2(0, 1) },  // Down
        { "W", new Vector2(-1, 0) }, // Left
        { "E", new Vector2(1, 0) },  // Right
    };    

    public Map(int width, int height)
    {
        cells = new Cell[width, height];
        harvested = new HashSet<Cell>();
        targeted = new HashSet<Cell>();
        this.width = cells.GetLength(0);
        this.height = cells.GetLength(1);
        directionVectorsToKeys = directionKeysToVectors.ToDictionary(kvp => kvp.Value, kvp => kvp.Key);
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                cells[x, y] = new Cell
                {
                    position = new Vector2(x, y),
                    entity = null,
                    isDirty = true,
                };
            }
        }
    }

    public bool IsAdjacentToFacingTentacle(Cell cell)
    {
        return targeted.Contains(cell);
    }

    public IEnumerable<Cell> GetNeighbours(Cell cell)
    {
        foreach (var dir in directionKeysToVectors.Values)
        {
            int newX = (int)cell.position.X + (int)dir.X;
            int newY = (int)cell.position.Y + (int)dir.Y;

            if (newX >= 0 && newX < width && newY >= 0 && newY < height)
            {
                yield return cells[newX, newY];
            }
        }
    }

    public void SetEntities(IEnumerable<IEntity> entities)
    {
        var addedEntities = new List<IEntity>();
        var removedEntities = new List<IEntity>();
        var harvestedIds = new HashSet<string>();

        foreach (var cell in cells)
        {
            cell.isDirty = true;
            cell.isTarget = false;
        }

        foreach (var entity in entities)
        {
            Cell cell = GetCellAtEntityPosition(entity);
            if (cell.entity?.id == entity.id)
            {
                // still the same entity as last turn
                cell.isDirty = false;

                // Player.Log($"No Change: ({cell.position.X},{cell.position.Y}): {cell.entity}");            
            }
            else
            {
                // entity was added to cell
                cell.entity = entity;
                cell.isDirty = false;
                addedEntities.Add(entity);
                
                if (cell.entity is Organ oEntity) 
                {
                    if (oEntity.type == OrganType.Harvester
                        && oEntity.isPlayerOwned)
                    {
                        var facing = GetCellForPositionAtDirection(cell, oEntity.direction);
                        if (facing != null && facing.entity is Protein pEntity)
                        {
                            pEntity.isHarvested = true;
                            facing.entity = pEntity;
                            harvestedIds.Add(facing.entity.id);
                            harvested.Add(facing);
                        }
                    }

                    if (oEntity.type == OrganType.Tentacle
                        && !oEntity.isPlayerOwned)
                    {
                        var facing = GetCellForPositionAtDirection(cell, oEntity.direction);
                        if (facing != null && !(facing.entity is Wall))
                        {
                            targeted.Add(facing);
                            // Player.Log($"Cell {facing} is targetted");
                        }
                    }
                }

                // Player.Log($"Added: ({cell.position.X},{cell.position.Y}): {cell.entity}");
            }
        }

        foreach (var cell in cells)
        {
            if (cell.isDirty)
            {
                if (cell.entity != null)
                {
                    // entity was removed from cell
                    var prev = cell.entity;
                    removedEntities.Add(prev);
                    cell.entity = null;
                    cell.isDirty = false;

                    if (prev is Organ oEntity) 
                    {
                        if (oEntity.type == OrganType.Harvester
                            && oEntity.isPlayerOwned)
                        {
                            var facing = GetCellForPositionAtDirection(cell, oEntity.direction);
                            if (facing != null && facing.entity is Protein pEntity)
                            {
                                pEntity.isHarvested = false;
                                facing.entity = pEntity;                               
                                harvested.Remove(facing);
                            }
                        }

                        if (oEntity.type == OrganType.Tentacle
                            && !oEntity.isPlayerOwned)
                        {
                            var facing = GetCellForPositionAtDirection(cell, oEntity.direction);
                            if (facing != null && !(facing.entity is Wall))
                            {
                                targeted.Remove(facing);
                                // Player.Log($"Cell {facing} is not targetted");
                            }
                        }
                    }

                    // Player.Log($"Removed: ({cell.position.X},{cell.position.Y}): {prev}");
                }
                else
                {
                    // empty cell
                    cell.isDirty = false;

                    // Player.Log($"Empty: ({cell.position.X},{cell.position.Y}): {cell.entity}");
                }
            }
        }

        harvested.RemoveWhere(x => !(x.entity is Protein));
        OnEntitiesAdded = addedEntities;
        OnEntitiesRemoved = removedEntities;
        OnProteinsHarvested = harvestedIds;
    }

    public Cell GetCellAtEntityPosition(IEntity entity)
    {
        return GetCellAtPosition(entity.position);
    }

    public Cell GetCellAtPosition(Vector2 position)
    {
        return cells[(int)position.X, (int)position.Y];
    }

    public string[] GetUnoccupiedDirections(Vector2 position, bool includeOpponentOrgans = false)
    {        
        var entityCell = cells[(int)position.X, (int)position.Y];
        var neighbours = GetNeighbours(entityCell);

        var unoccupiedDirections = new List<string>();
        foreach (var neighbour in neighbours)
        {           
            var directionVector = neighbour.position - entityCell.position;
            bool isUnnocupied =  neighbour.isEmpty 
                || (includeOpponentOrgans && (neighbour.entity is Organ oEntity && !oEntity.isPlayerOwned));
            if (isUnnocupied && directionVectorsToKeys.TryGetValue(directionVector, out var directionKey))
            {
                unoccupiedDirections.Add(directionKey);
            }
        }

        return unoccupiedDirections.ToArray();
    }

    public int GetDistanceToClosestOrgan(Cell cell, bool isPlayerOrgan)
    {
        var organTargets = cells
            .Cast<Cell>()
            .Where(x => !x.isEmpty && x.entity is Organ oEntity && oEntity.isPlayerOwned == isPlayerOrgan)
            .Select(x => (Organ)x.entity)
            .ToArray();

        int closest = 9999;
        foreach (var organ in organTargets)
        {
            int distance = Map.Distance(organ.position, cell.position);
            if (closest > distance)
            {
                closest = distance;
            }
        }

        return closest;
    }

    public Cell GetCellForPositionAtDirection(Cell cell, string direction)
    {
        if (!directionKeysToVectors.ContainsKey(direction))
        {
            return null;
        }

        Vector2 offset = directionKeysToVectors[direction];
        Vector2 targetPos = cell.position + offset;

        int targetX = (int)targetPos.X;
        int targetY = (int)targetPos.Y;

        if (targetX >= 0 && targetX < width && targetY >= 0 && targetY < height)
        {
            return cells[targetX, targetY];
        }

        return null;
    }

    public static int Distance(Vector2 a, Vector2 b)
    {
        return Math.Abs((int)b.X - (int)a.X) + Math.Abs((int)b.Y - (int)a.Y);
    }

    public static string GetDirectionKey(Vector2 dir)
    {
        return directionKeysToVectors.FirstOrDefault(x => x.Value == dir).Key;
    }
}

public class Cell
{
    public Vector2 position;
    public IEntity entity;
    public bool isTarget;
    public bool isDirty;

    public bool isEmpty => entity == null;
    public bool hasObstacle => isTarget || (!isEmpty && entity.isObstacle);

    public override string ToString()
    {
        return $"({position.X},{position.Y}): {entity}";
    }
}

public class Organism
{
    private HashSet<int> organIds = new HashSet<int>();    

    private int minDistanceToHarvest = 1;
    private int maxDistanceToHarvest = 6;
    private int maxDeviationToHarvest = 6;
    private int minDistanceToDefend = 1;
    private int maxDistanceToDefend = 3;
    private int maxDeviationToDefend = 3;
    private int minExistingSporingDistanceFromOrigin = 3;
    private int minExistingSporingDistanceFromSelf = 3;
    private int minExistingSporingDistanceFromOpponent = 2;
    private int minNewSporingDistanceFromOrigin = 5;
    private int minNewSporingDistanceFromSelf = 3;
    private int minNewSporingDistanceFromOpponent = 2;

    public int id;
    public Organ root;
    public List<Organ> organs = new List<Organ>();
    public ProteinReserve proteins;
    public Map map;
    public Navigation navigation;
    public int actions = 1;    
    public bool hasNoMoreActions = false;
    public bool expandIntoHarvestedProteins = false;

    public bool IsPlayerOwned => root.isPlayerOwned;

    private HashSet<ProteinType> desired = new HashSet<ProteinType>()
    {
        ProteinType.A,
        ProteinType.B,
        ProteinType.C,
        ProteinType.D,
    };

    public void AddOrgan(Organ organ)
    {
        if (organIds.Contains(organ.organId))
        {
            return;
        }

        this.organs.Add(organ);
        this.organIds.Add(organ.organId);
        if (organ.type == OrganType.Root)
        {
            root = organ;
        }
    }

    public void Prepare()
    {
        var organIdsToRemove = new HashSet<int>();
        foreach (var removal in map.OnEntitiesRemoved)
        {
            if (removal is Organ org && organIds.Contains(org.organId))
            {
                organIdsToRemove.Add(org.organId);
            }
        }

        organs.RemoveAll(x => organIdsToRemove.Contains(x.organId));
        navigation.Refresh();
        actions = 1;
        hasNoMoreActions = false;
    }

    public void Act()
    {
        // defense
        Player.AddComment("DEFENDING", clear: true);
        if (navigation.TryFindNearestOpponent(this, minDistanceToDefend, maxDistanceToDefend, maxDeviationToDefend, out Navigation.NavigationData opponentNavData))
        {
            Organ org = (Organ)opponentNavData.origin.entity;
            Organ op = (Organ)opponentNavData.target.entity;
            int distToOp = opponentNavData.distance;
            List<Vector2> pathToOp = opponentNavData.path;            
            if (Defend(org,op, distToOp, pathToOp))
            {                
                return;
            }
        }

        // divide if we have an existing sporer and collected enough proteins
        if (desired.Count == 0 || proteins.HasAll(3))
        {            
            Player.AddComment("SPORING", clear: true);
            if (navigation.TryGetSporerAndLocation(this, minExistingSporingDistanceFromOrigin, minExistingSporingDistanceFromSelf, minExistingSporingDistanceFromOpponent, out Organ sporer, out Vector2 sporePos))
            {
                Player.Log($"found sporer {sporer} and location {sporePos}");
                if (Spore(sporer, sporePos))
                {
                    return;
                }
            }            
        }

        // grow a new sporer if we have collected enough proteins
        if (desired.Count == 0 || proteins.HasAll(4))
        {
            Player.AddComment("GROWING SPORER", clear: true);
            if (CanGrow(OrganType.Sporer) 
                && navigation.TryGetSporerLocation(this, minNewSporingDistanceFromOrigin, minNewSporingDistanceFromSelf, minNewSporingDistanceFromOpponent, out Organ parent, out Vector2 sporerPos, out string sporerDir))
            {
                if (TryGrowSporer(parent, sporerPos, sporerDir))
                {
                    return;
                }
            }
        }

        // harvest
        Player.AddComment("HARVESTING", clear: true);
        if (navigation.TryFindNearestProtein(this, minDistanceToHarvest, maxDistanceToHarvest, maxDeviationToHarvest, desired, out Navigation.NavigationData proteinNavData))
        {
            Organ org = (Organ)proteinNavData.origin.entity;
            Protein prot = (Protein)proteinNavData.target.entity;
            int distToProt = proteinNavData.distance;
            List<Vector2> pathToProt = proteinNavData.path;            
            if (HarvestProtein(org, prot, distToProt, pathToProt))
            {
                return;
            }
        }

        // expand to empty tiles
        Player.AddComment("EXPANDING EMPTY", clear: true);
        if (TryGetRandomPositionForRandomOrgan(out var organ, out var target, ignoreProteins: false))
        {
            var dirs = map.GetUnoccupiedDirections(target.position);
            if (TryGrowAny(organ, target.position, dirs.FirstOrDefault()))
            {
                return;
            }
        }        

        // if we want expand onto empty tiles, start occupying tiles containing proteins we harvest
        // only start occupying protein tiles if all organisms we control dont have additional actions
        Player.AddComment("EXPANDING ALL", clear: true);
        hasNoMoreActions = true;

        if (expandIntoHarvestedProteins && TryGetRandomPositionForRandomOrgan(out organ, out target, ignoreProteins: true))
        {
            if (TryGrowAny(organ, target.position, string.Empty))
            {
                return;
            }
        }

        // if no proteins or spaces left just wait for the game to end
        Player.AddComment("WAITING", clear: true);
        Player.Command("WAIT");
    }

    private bool TryGetRandomPositionForRandomOrgan(out Organ organ, out Cell target, bool ignoreProteins = false)
    {
        foreach (var o in organs)
        {
            var cell = map.GetCellAtEntityPosition(o);
            var neighbours = map.GetNeighbours(cell);
            foreach (var n in neighbours)
            {
                if (!map.Targeted.Contains(n) && (n.isEmpty || (ignoreProteins && n.entity is Protein)))
                {
                    organ = o;
                    target = n;
                    return true;
                }
            }
        }

        organ = default;
        target = default;
        return false;
    }

    private bool HarvestProtein(Organ organ, Protein protein, int distance, List<Vector2> path)
    {
        // Player.Log($"Closest protein to {organ} is {protein} | Distance: {distance} | Path: [{string.Join(", ", path)}]");
        if (distance == 2 && CanGrow(OrganType.Harvester))
        {
            Vector2 harvesterPos = path[0];
            Vector2 harvesterDir = Vector2.Normalize(protein.position - harvesterPos);
            string dirKey = Map.GetDirectionKey(harvesterDir);
            if (TryGrowHarvester(organ, harvesterPos, dirKey))
            {
                desired.Remove(protein.type);
                return true;
            }
        }
        else
        {
            var dirs = map.GetUnoccupiedDirections(path[0]);
            if (TryGrowAny(organ, path[0], dirs.FirstOrDefault()))
            {
                return true;
            }
        }

        return false;
    }

    private bool Defend(Organ organ, Organ op, int distance, List<Vector2> path)
    {
        // Player.Log($"Closest opponent to {organ} is {op} | Distance: {distance} | Path: [{string.Join(", ", path)}]");
        if (distance == 2 && CanGrow(OrganType.Tentacle))
        {
            Vector2 tentaclePos = path[0];
            Vector2 tentacleDir = Vector2.Normalize(op.position - tentaclePos);
            string dirKey = Map.GetDirectionKey(tentacleDir);
            if (TryGrowTentacle(organ, tentaclePos, dirKey))
            {                
                return true;
            }
        }

        return false;
    }

    public bool TryGrowBasic(Organ organ, Vector2 destination)
    {
        return Grow(organ, OrganType.Basic, destination, "N");
    }

    public bool TryGrowHarvester(Organ organ, Vector2 destination, string direction)
    {
        return Grow(organ, OrganType.Harvester, destination, direction);
    }

    public bool TryGrowTentacle(Organ organ, Vector2 destination, string direction)
    {
        return Grow(organ, OrganType.Tentacle, destination, direction);
    }

    public bool TryGrowSporer(Organ organ, Vector2 destination, string direction)
    {
        return Grow(organ, OrganType.Sporer, destination, direction);
    }

    public bool TryGrowAny(Organ organ, Vector2 destination, string direction)
    {
        if (TryGrowBasic(organ, destination)
            || TryGrowTentacle(organ, destination, direction)
            || TryGrowSporer(organ, destination, direction)
            || TryGrowHarvester(organ, destination, direction))
        {
            return true;
        }

        return false;
    }

    public bool CanGrow(OrganType organType)
    {
        if (actions < 1)
        {
            return false;
        }

        switch (organType)
        {
            case OrganType.Basic:
                return proteins.a >= 1;
            case OrganType.Harvester:
                return proteins.c >= 1 && proteins.d >= 1;
            case OrganType.Tentacle:
                return proteins.b >= 1 && proteins.c >= 1;
            case OrganType.Sporer:
                return proteins.b >= 1 && proteins.d >= 1;
        }

        return false;
    }

    public bool CanSpore(Organ organ)
    {
        return organ.type == OrganType.Sporer
            && actions >= 1
            && proteins.a > 0
            && proteins.b > 0
            && proteins.c > 0
            && proteins.d > 0;
    }

    private bool Grow(Organ organ, OrganType growthType, Vector2 destination, string direction)
    {
        if (!CanGrow(growthType) || HasIntent(destination))
        {
            return false;
        }

        PayGrowthCosts(growthType);
        Player.Log($"Organ {organ.organId} (organism {id}) is growing a {growthType} from {organ.position} to {destination} facing {direction}");
        Player.Command($"GROW {organ.organId} {destination.X} {destination.Y} {growthType.ToString().ToUpper()} {direction}"/*, $"GROWING {growthType}"*/);
        AddIntent(destination);
        return true;
    }

    public bool Spore(Organ organ, Vector2 destination)
    {
        if (!CanSpore(organ) || HasIntent(destination))
        {
            return false;
        }

        PaySporeCosts();
        Player.Log($"Organ {organ.organId} (organism {id}) is sporing a root from {organ.position} to {destination}");
        Player.Command($"SPORE {organ.organId} {destination.X} {destination.Y}");
        AddIntent(destination);
        return true;
    }

    private void PayGrowthCosts(OrganType organType)
    {
        switch (organType)
        {
            case OrganType.Basic:
                proteins.a--;
                break;
            case OrganType.Harvester:
                proteins.c--;
                proteins.d--;
                break;
            case OrganType.Tentacle:
                proteins.b--;
                proteins.c--;
                break;
            case OrganType.Sporer:
                proteins.b--;
                proteins.d--;
                break;
        }

        actions--;
    }

    private void PaySporeCosts()
    {
        proteins.a--;
        proteins.b--;
        proteins.c--;
        proteins.d--;
        actions--;
    }

    private bool HasIntent(Vector2 destination)
    {
        return map.GetCellAtPosition(destination).isTarget;
    }

    private void AddIntent(Vector2 destination)
    {
        map.GetCellAtPosition(destination).isTarget = true;
    }
}

public class Navigation
{
    public struct RaycastHit
    {
        public Cell origin;
        public Cell target;
        public List<Cell> path;
        public int distance;

        public override string ToString()
        {
            return $"{origin.position} => {target.position} | Distance: {distance} | Path: {string.Join(", ", path)}";
        }
    }

    public struct NavigationData
    {
        public Cell origin;
        public Cell target;
        public int distance;
        public int score;
        public int deviation;
        public List<Vector2> path;
        public HashSet<Vector2> pathSet;

        public override string ToString()
        {
            return $"{origin.position} => {target.position} | Distance: {distance} | Path: {string.Join(", ", path)}";
        }
    }

    private Map map;
    private IPathfinder pathfinder;

    // first string is organId
    // first integer is distance between organ and entity
    // second string is entityId
    private Dictionary<string, SortedDictionary<int, Dictionary<string, NavigationData>>> organToProteinsNavDict;
    private Dictionary<string, Dictionary<string, int>> opponentDistanceNavDict;

    public Navigation(Map map)
    {
        this.map = map;
        this.pathfinder = new AStar(map);      
        organToProteinsNavDict = new Dictionary<string, SortedDictionary<int, Dictionary<string, NavigationData>>>();
        opponentDistanceNavDict = new Dictionary<string, Dictionary<string, int>>();
    }

    public void Refresh()
    {
        OnEntitiesAdded(map.OnEntitiesAdded);
        OnEntitiesRemoved(map.OnEntitiesRemoved);
        OnProteinsHarvested(map.OnProteinsHarvested);
    }

    public bool TryFindNearestProtein(Organism organism, int minDistance, int maxDistance, int maxDeviation, HashSet<ProteinType> types, out NavigationData data)
    {
        data = default;
        Cell closest = null;
        int smallestScore = int.MaxValue;        

        foreach (Organ organ in organism.organs)
        {
            if (!organToProteinsNavDict.TryGetValue(organ.id, out var scoreNavDict))
            {
                scoreNavDict = FindPathsToAllProteins(organ, maxDistance: maxDistance, maxDeviation: maxDeviation, includeHarvested: true);
            }

            if (scoreNavDict.Count < 1)
            {
                continue;
            }

            var result = scoreNavDict.FirstOrDefault(x => CachedSearchResultSelector(x, minDistance, types));
            if (result.Equals(default(KeyValuePair<int, NavigationData>)) || result.Value == null || result.Value.Count < 1)
            {
                continue;
            }

            var navData = result.Value.FirstOrDefault(x => CachedSearchResultSelector(x, minDistance, types)).Value;
            if (navData.Equals(default(NavigationData)))
            {
                continue;
            }

            if (navData.score < smallestScore)
            {
                data = navData;
                closest = navData.target;
                smallestScore = navData.score;
            }
        }

        return closest != null;
    }

    public bool TryFindNearestOpponent(Organism organism, int minDistance, int maxDistance, int maxDeviation, out NavigationData data)
    {
        var opponentOrgans = map.Cells
            .Cast<Cell>()
            .Where(x => x.entity is Organ oEntity && !oEntity.isPlayerOwned)
            .Select(x => (Organ)x.entity)
            .ToArray();

        var ranking = new SortedDictionary<int, List<(Cell organ, Cell op)>>();
        foreach (var organ in organism.organs)
        {
            foreach (var op in opponentOrgans)
            {
                if (!opponentDistanceNavDict.TryGetValue(organ.id, out var opDict)
                    || !opDict.TryGetValue(op.id, out int dist))
                {
                    opponentDistanceNavDict.TryAdd(organ.id, new Dictionary<string, int>());
                    opponentDistanceNavDict[organ.id].TryAdd(op.id, Map.Distance(organ.position, op.position));

                }

                var organCell = map.GetCellAtEntityPosition(organ);
                var opCell = map.GetCellAtEntityPosition(op);

                int currentDistance = opponentDistanceNavDict[organ.id][op.id];
                if (currentDistance > minDistance && currentDistance < maxDistance)
                {
                    var cellData = (organCell, opCell);
                    ranking.TryAdd(currentDistance, new List<(Cell organ, Cell op)>());
                    ranking[currentDistance].Add(cellData);
                }
            }
        }

        for (int i = 0; i < ranking.Count; i++)
        {        
            var r = ranking.ElementAt(i);
            var navDataDict = new SortedDictionary<int, List<NavigationData>>();            
            foreach (var cd in r.Value)
            {                
                if (TryGetPath(cd.organ, cd.op, maxDeviation, ignoreProteins: true, out PathResult path))
                {                    
                    int dist = path.cells.Count;
                    var cells = path.cells.Select(x => x.position);
                    navDataDict.TryAdd(dist, new List<NavigationData>());
                    navDataDict[dist].Add(new NavigationData
                    {
                        origin = cd.organ,
                        target = cd.op,
                        distance = dist,
                        score = path.score,
                        deviation = maxDeviation,
                        path = cells.ToList(),
                        pathSet = cells.ToHashSet(),
                    });
                }
            }

            if (navDataDict.Count > 0)
            {
                data = navDataDict.First().Value.First();        
                return true;
            }
        }

        data = default;
        return false;
    }

    public bool TryGetSporerAndLocation(Organism organism, int minDistanceFromOrigin, int minDistanceFromSelf, int minDistanceFromOpponent, out Organ organ, out Vector2 position)
    {
        var sporers = organism.organs
            .Where(x => x.type == OrganType.Sporer)
            .ToArray();

        var ranking = new SortedDictionary<int, List<(Organ organ, Vector2 position)>>();
        foreach (var sporer in sporers)
        {
            var cell = map.GetCellAtEntityPosition(sporer);
            var raycastHits = RaycastAll(cell, sporer.direction);
            foreach (var hit in raycastHits)
            {
                if (hit.distance >= minDistanceFromOrigin)
                {
                    int closestPlayerDist = map.GetDistanceToClosestOrgan(hit.target, isPlayerOrgan: true);
                    int closestOpponentDist = map.GetDistanceToClosestOrgan(hit.target, isPlayerOrgan: false);
                    if (closestPlayerDist >= minDistanceFromSelf 
                        && closestOpponentDist >= minDistanceFromOpponent)
                    {
                        int score = GetSporerLocationScore(hit, closestPlayerDist, closestOpponentDist);
                        ranking.TryAdd(score, new List<(Organ organ, Vector2 position)>());
                        ranking[score].Add((sporer, hit.target.position));
                    }                   
                }
            } 
        }        

        for (int i = ranking.Count; i --> 0; )
        {
            var r = ranking.ElementAt(i);
            var result = r.Value.FirstOrDefault();
            organ = result.organ;
            position = result.position;
            return true;
        }

        organ = default;
        position = default;
        return false;
    }

    public bool TryGetSporerLocation(Organism organism, int minDistanceFromOrigin, int minDistanceFromSelf, int minDistanceFromOpponent, out Organ organ, out Vector2 position, out string direction)
    {
        Organ? longest = default;
        Vector2 longestPos = default;
        string longestDir = default;
        int longestDist = minDistanceFromOrigin;
        foreach (var org in organism.organs)
        {
            var cell = map.GetCellAtEntityPosition(org);
            foreach (var neighbour in map.GetNeighbours(cell))
            {
                if (neighbour.entity != null && neighbour.hasObstacle)
                {
                    continue;
                }
                
                foreach (var dir in Map.directionKeysToVectors.Keys)
                {
                    var raycastHit = Raycast(cell, dir);
                    int closestPlayerDist = map.GetDistanceToClosestOrgan(raycastHit.target, isPlayerOrgan: true);
                    int closestOpponentDist = map.GetDistanceToClosestOrgan(raycastHit.target, isPlayerOrgan: false);
                    if (raycastHit.distance >= longestDist 
                        && closestPlayerDist >= minDistanceFromSelf 
                        && closestOpponentDist >= minDistanceFromOpponent)
                    {
                        longestDist = raycastHit.distance;
                        longest = org;
                        longestPos = neighbour.position;
                        longestDir = dir;
                    }
                }
            }
        }

        organ = longest.HasValue ? longest.Value : default;
        position = longestPos;
        direction = longestDir;
        return longest.HasValue;
    }

    private int GetSporerLocationScore(RaycastHit hit, int closestPlayerDist, int closestOpponentDist)
    {
        int numOfEmptyNeighbours = map
            .GetNeighbours(hit.target)
            .Where(x => !x.hasObstacle)
            .Count();

        int distanceScore = hit.distance;
        int closestPlayerDistScore = closestPlayerDist * 2;
        int closestOpponentDistScore = Math.Min(closestOpponentDist, 4);
        int emptyNeighbourScore = numOfEmptyNeighbours * 2;
        int score = distanceScore + closestPlayerDistScore + closestOpponentDistScore + emptyNeighbourScore;
        Player.Log($"Score: {hit.target} | {score} => {hit.distance} {(closestPlayerDist * 2)} {numOfEmptyNeighbours}");
        return score;
    }

    private RaycastHit Raycast(Cell origin, string dir)
    {
        Cell hit = null;
        var path = new List<Cell>();
        int distance = 0;

        Cell last = origin;
        while(last != null)
        {
            var neighbour = map.GetCellForPositionAtDirection(last, dir);
            if (neighbour == null || (neighbour.entity != null && neighbour.hasObstacle))
            {
                hit = last;
                return new RaycastHit
                {
                    origin = origin,
                    target = hit,
                    path = path,
                    distance = distance,
                };
            }
            
            distance++;
            last = neighbour;
            path.Add(neighbour);
        }

        return default;
    }

    private List<RaycastHit> RaycastAll(Cell origin, string dir)
    {
        List<RaycastHit> paths = new List<RaycastHit>();

        var path = new List<Cell>();
        int distance = 1;
        Cell last = origin;
        while(last != null)
        {
            var neighbour = map.GetCellForPositionAtDirection(last, dir);
            if (neighbour == null || (neighbour.entity != null && neighbour.hasObstacle))
            {                
                return paths;
            }

            paths.Add(new RaycastHit
            {
                origin = origin,
                target = neighbour,
                path = path,
                distance = distance,
            });

            distance++;
            last = neighbour;
            path.Add(neighbour);            
        }

        return default;
    }

    private bool CachedSearchResultSelector(KeyValuePair<int, Dictionary<string, NavigationData>> kvp, int minDistance, HashSet<ProteinType> types)
    {
        bool isOverMinDistance = kvp.Value.Any(y => y.Value.distance > minDistance);
        bool isNotHarvested = kvp.Value.Any(y => y.Value.target.entity is Protein pEntity && !pEntity.isHarvested);
        bool requiresType = types != null && types.Count > 0;
        bool isOfRequiredType = kvp.Value.Any(y => y.Value.target.entity is Protein pEntity && types.Contains(pEntity.type));
        return isOverMinDistance
            & isNotHarvested
            && (!requiresType || isOfRequiredType);
    }

    private bool CachedSearchResultSelector(KeyValuePair<string, NavigationData> kvp, int minDistance, HashSet<ProteinType> types)
    {
        bool isProtein = kvp.Value.target.entity is Protein;
        bool isOverMinDistance = kvp.Value.distance > minDistance;
        bool isNotHarvested = isProtein && !((Protein)kvp.Value.target.entity).isHarvested;
        bool requiresType = types != null && types.Count > 0;
        bool isOfRequiredType = isProtein && types.Contains(((Protein)kvp.Value.target.entity).type);
        return isNotHarvested
            && (!requiresType || isOfRequiredType);
    }    

    private SortedDictionary<int, Dictionary<string, NavigationData>> FindPathsToAllProteins(Organ organ, int maxDistance, int maxDeviation, HashSet<ProteinType> types = null, bool includeHarvested = false)
    {
        Cell organCell = map.GetCellAtEntityPosition(organ);
        Cell[] proteins = map.Cells
            .Cast<Cell>()
            .Where(x => x.entity is Protein pEntity
                && (types == null || types.Contains(pEntity.type))
                && (includeHarvested || !pEntity.isHarvested)
                && !map.Targeted.Contains(x)
                && Map.Distance(organ.position, x.position) <= maxDistance)
            .ToArray();

        foreach (var protein in proteins)
        {
            CalculatePathFromOrganToProtein(organCell, protein, maxDeviation);
        }

        // in case we dont find any valid paths
        organToProteinsNavDict.TryAdd(organ.id, new SortedDictionary<int, Dictionary<string, NavigationData>>());
        return organToProteinsNavDict[organ.id];
    }

    private void CalculatePathFromOrganToProtein(Cell start, Cell end, int maxDeviation)
    {
        if (start.entity == null || end.entity == null || !TryGetPath(start, end, maxDeviation, false, out var path))
        {
            return;
        }
        
        var cells = path.cells.Select(x => x.position);
        organToProteinsNavDict.TryAdd(start.entity.id, new SortedDictionary<int, Dictionary<string, NavigationData>>());
        organToProteinsNavDict[start.entity.id].TryAdd(path.score, new Dictionary<string, NavigationData>());
        var navData = new NavigationData
        {
            origin = start,
            target = end,
            distance = path.cells.Count,
            score = path.score,
            deviation = maxDeviation,
            path = cells.ToList(),
            pathSet = cells.ToHashSet(),
        };

        organToProteinsNavDict[start.entity.id][path.score].TryAdd(end.entity.id, navData);
    }

    private bool TryGetPath(Cell start, Cell end, int maxDeviation, bool ignoreProteins, out PathResult path)
    {
        path = pathfinder.GetPath(start, end, maxDeviation, ignoreProteins);
        return path != null;
    }

    private void OnEntitiesAdded(IEnumerable<IEntity> entities)
    {
        if (entities.Count() > 0)
        {
            var recalculations = new List<Action>();
            var entityPositions = entities
                .Select(x => x.position)
                .ToHashSet();

            for (int i = 0; i < organToProteinsNavDict.Count; i++)
            {
                var distanceDict = organToProteinsNavDict.ElementAt(i).Value;
                for (int j = 0; j < distanceDict.Count; j++)
                {
                    var distanceKvp = distanceDict.ElementAt(j);
                    var entityNavDict = distanceKvp.Value;
                    for (int k = 0; k < entityNavDict.Count; k++)
                    {
                        var kvp = entityNavDict.ElementAt(k);
                        var navData = kvp.Value;
                        if (navData.pathSet.Overlaps(entityPositions))
                        {
                            recalculations.Add(delegate
                            {
                                entityNavDict.Remove(kvp.Key);
                                CalculatePathFromOrganToProtein(navData.origin, navData.target, navData.deviation);
                            });
                        }

                        if (entityNavDict.Count < 1)
                        {
                            distanceDict.Remove(distanceKvp.Key);
                        }
                    }
                }
            }            

            foreach (var recalc in recalculations)
            {
                recalc?.Invoke();
            }
        }
    }

    private void OnEntitiesRemoved(IEnumerable<IEntity> entities)
    {
        if (entities.Count() > 0)
        {
            var recalculations = new List<Action>();
            var entityPositions = entities
                .Select(x => x.position)
                .ToHashSet();

            foreach (var entity in entities)
            {
                organToProteinsNavDict.Remove(entity.id);
                
                if (entity is Organ oEntity)
                {
                    if (oEntity.isPlayerOwned)
                    {
                        opponentDistanceNavDict.Remove(entity.id);
                    }
                    else
                    {
                        for (int i = 0; i < opponentDistanceNavDict.Count; i++)
                        {
                            var opOrgansDict = opponentDistanceNavDict.ElementAt(i).Value;
                            opOrgansDict.Remove(entity.id);
                        }
                    }
                }                
            }

            for (int i = 0; i < organToProteinsNavDict.Count; i++)
            {
                var distanceDict = organToProteinsNavDict.ElementAt(i).Value;
                for (int j = 0; j < distanceDict.Count; j++)
                {
                    var distanceKvp = distanceDict.ElementAt(j);
                    var entityNavDict = distanceKvp.Value;

                    foreach (var entity in entities)
                    {
                        entityNavDict.Remove(entity.id);
                    }

                    for (int k = 0; k < entityNavDict.Count; k++)
                    {
                        var kvp = entityNavDict.ElementAt(k);
                        var navData = kvp.Value;
                        if (navData.pathSet.Overlaps(entityPositions))
                        {
                            recalculations.Add(delegate
                            {
                                entityNavDict.Remove(kvp.Key);
                                CalculatePathFromOrganToProtein(navData.origin, navData.target, navData.deviation);
                            });
                        }
                    }

                    if (entityNavDict.Count < 1)
                    {
                        distanceDict.Remove(distanceKvp.Key);
                    }
                }
            }            

            foreach (var recalc in recalculations)
            {
                recalc?.Invoke();
            }
        }
    }

    private void OnProteinsHarvested(HashSet<string> proteinIds)
    {
        foreach (var pid in proteinIds)
        {
            for (int i = 0; i < organToProteinsNavDict.Count; i++)
            {
                var distanceDict = organToProteinsNavDict.ElementAt(i).Value;
                for (int j = 0; j < distanceDict.Count; j++)
                {
                    var distanceKvp = distanceDict.ElementAt(j);
                    var entityNavDict = distanceKvp.Value;
                    entityNavDict.Remove(pid);
                    if (entityNavDict.Count < 1)
                    {
                        distanceDict.Remove(distanceKvp.Key);
                    }
                }
            }
        }
    }
}

public interface IPathfinder
{
    PathResult GetPath(Cell start, Cell end, int maxDeviation, bool ignoreProteins);
}

public class PathResult
{
    public List<Cell> cells;
    public int score;
}

public class AStar : IPathfinder
{    
    private class Node
    {
        public Cell Cell { get; set; }
        public int FCost { get; set; }
        public int GCost { get; set; }
        public int HCost { get; set; }
        public Node Parent { get; set; }
    }

    private Map map = default;
    private PriorityQueue<Node, int> openList;
    private HashSet<Cell> closedList;

    public AStar(Map map)
    {
        this.map = map;
        openList = new PriorityQueue<Node, int>();
        closedList = new HashSet<Cell>();
    }

    public PathResult GetPath(Cell start, Cell end, int maxDeviation, bool ignoreProteins)
    {
        openList.Clear();
        closedList.Clear();

        // Initialize the starting node
        var startNode = new Node
        {
            Cell = start,
            GCost = 0,  // No cost to start
            HCost = GetHCost(start, end), // Heuristic cost to the end
            FCost = 0 + GetHCost(start, end),
            Parent = null,
        };

        openList.Enqueue(startNode, startNode.FCost);

        while (openList.Count > 0)
        {
            // Get the node with the lowest fCost (highest priority)
            var currentNode = openList.Dequeue();

            // If we've reached the target, reconstruct the path
            if (currentNode.Cell == end)
            {
                return ReconstructPath(currentNode);
            }

            closedList.Add(currentNode.Cell);

            foreach (var neighbor in GetNeighbours(currentNode.Cell))
            {
                bool isDestination = neighbor == end;
                bool isObstacle = (neighbor.entity != null && neighbor.hasObstacle);      
                bool isTooFar = GetHCost(neighbor, start) > maxDeviation;
                if (!isDestination && (isObstacle || isTooFar || IsAdjacentToFacingTentacle(neighbor) || closedList.Contains(neighbor)))
                {
                    continue;
                }

                int tentativeGCost = currentNode.GCost + GetMovementCost(currentNode.Cell, neighbor, ignoreProteins);

                // If the neighbor is not in the open list, or we found a shorter path to it
                var neighborNode = new Node
                {
                    Cell = neighbor,
                    GCost = tentativeGCost,
                    HCost = GetHCost(neighbor, end),
                    FCost = tentativeGCost + GetHCost(neighbor, end),
                    Parent = currentNode,
                };

                openList.Enqueue(neighborNode, neighborNode.FCost);
            }
        }

        return null;
    }

    private PathResult ReconstructPath(Node node)
    {
        var path = new List<Cell>();
        int gCost = 0;
        while (node != null)
        {
            if (node.Parent != null)
            {
                path.Add(node.Cell);
            }
            
            gCost += node.GCost - (node.Parent?.GCost ?? 0);
            node = node.Parent;
        }

        path.Reverse();
        return new PathResult
        {
            cells = path,
            score = gCost,
        };
    }

    // Heuristic cost (e.g., Manhattan distance)
    private int GetHCost(Cell cell, Cell end)
    {
        return Map.Distance(cell.position, end.position);
    }

    private int GetMovementCost(Cell from, Cell to, bool ignoreProteins)
    {
        if (!ignoreProteins && to.entity != null && to.entity is Protein pEntity)
        {
            return pEntity.isHarvested 
                ? 15 
                : 10;
        }

        return 1;
    }

    private bool IsAdjacentToFacingTentacle(Cell cell)
    {
        return map.IsAdjacentToFacingTentacle(cell);        
    }

    private IEnumerable<Cell> GetNeighbours(Cell cell)
    {
        return map.GetNeighbours(cell);
    }
}

public struct Organ : IEntity
{
    public string id { get; set; }
    public int organId { get; set; }
    public OrganType type { get; set; }
    public Vector2 position { get; set; }
    public string direction { get; set; }
    public bool isPlayerOwned { get; set; }    
    public bool isObstacle => true;

    public override string ToString()
    {
        return $"{id} {type} ({(isPlayerOwned ? "Player" : "Opponent")})";
    }
}

public struct Protein : IEntity
{
    public string id { get; set; }
    public ProteinType type { get; set; }
    public Vector2 position { get; set; }
    public bool isHarvested { get; set; }    
    public bool isObstacle => false;

    public override string ToString()
    {
        return $"{id} {type} (harvested: {isHarvested})";
    }
}

public struct Wall : IEntity
{
    public string id { get; set; }
    public Vector2 position { get; set; }  
    public bool isObstacle => true;  

    public override string ToString()
    {
        return $"{id}";
    }
}

public interface IEntity
{
    string id { get; }
    Vector2 position { get; }    
    bool isObstacle { get; }
}

public class ProteinReserve
{
    public int a;
    public int b;
    public int c;
    public int d;

    public bool HasAll(int amount)
    {
        return a >= amount
            && b >= amount
            && c >= amount
            && d >= amount;
    }
}

public enum OrganType
{
    Wall,
    Root,
    Basic,
    Tentacle,
    Harvester,
    Sporer
}

public enum ProteinType
{
    A,
    B,
    C,
    D
}
